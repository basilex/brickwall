// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: role.sql

package dbs

import (
	"context"
)

const roleCount = `-- name: RoleCount :one
select count(*) from role
`

// RoleCount
//
//	select count(*) from role
func (q *Queries) RoleCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, roleCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const roleDeleteByID = `-- name: RoleDeleteByID :one
delete from role where id = $1 returning id
`

// RoleDeleteByID
//
//	delete from role where id = $1 returning id
func (q *Queries) RoleDeleteByID(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRow(ctx, roleDeleteByID, id)
	err := row.Scan(&id)
	return id, err
}

const roleNew = `-- name: RoleNew :one
insert into role(name) values($1) returning id, name, created_at, updated_at
`

// RoleNew
//
//	insert into role(name) values($1) returning id, name, created_at, updated_at
func (q *Queries) RoleNew(ctx context.Context, name string) (*Role, error) {
	row := q.db.QueryRow(ctx, roleNew, name)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const roleSelect = `-- name: RoleSelect :many
select id, name, created_at, updated_at
  from role r
 order by $1::text
 limit $3 offset $2
`

type RoleSelectParams struct {
	SqlOrder  string `json:"sql_order"`
	SqlOffset int32  `json:"sql_offset"`
	SqlLimit  int32  `json:"sql_limit"`
}

// RoleSelect
//
//	select id, name, created_at, updated_at
//	  from role r
//	 order by $1::text
//	 limit $3 offset $2
func (q *Queries) RoleSelect(ctx context.Context, arg *RoleSelectParams) ([]*Role, error) {
	rows, err := q.db.Query(ctx, roleSelect, arg.SqlOrder, arg.SqlOffset, arg.SqlLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const roleSelectByID = `-- name: RoleSelectByID :one
select id, name, created_at, updated_at from role r where r.id = $1
`

// RoleSelectByID
//
//	select id, name, created_at, updated_at from role r where r.id = $1
func (q *Queries) RoleSelectByID(ctx context.Context, id string) (*Role, error) {
	row := q.db.QueryRow(ctx, roleSelectByID, id)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const roleSelectByName = `-- name: RoleSelectByName :one
select id, name, created_at, updated_at from role r where r.name = $1
`

// RoleSelectByName
//
//	select id, name, created_at, updated_at from role r where r.name = $1
func (q *Queries) RoleSelectByName(ctx context.Context, name string) (*Role, error) {
	row := q.db.QueryRow(ctx, roleSelectByName, name)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const roleUpdateByID = `-- name: RoleUpdateByID :one
update role
   set name = $1 where id = $2 returning id, name, created_at, updated_at
`

type RoleUpdateByIDParams struct {
	Name string `json:"name"`
	ID   string `json:"id"`
}

// RoleUpdateByID
//
//	update role
//	   set name = $1 where id = $2 returning id, name, created_at, updated_at
func (q *Queries) RoleUpdateByID(ctx context.Context, arg *RoleUpdateByIDParams) (*Role, error) {
	row := q.db.QueryRow(ctx, roleUpdateByID, arg.Name, arg.ID)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
