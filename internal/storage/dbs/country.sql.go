// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: country.sql

package dbs

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countryCount = `-- name: CountryCount :one
select count(*) from country
`

// CountryCount
//
//	select count(*) from country
func (q *Queries) CountryCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countryCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countryCurrencySelect = `-- name: CountryCurrencySelect :many
select cn.id, cn.name, cn.iso2, cn.iso3, cn.num_code, cn.created_at, cn.updated_at,
  coalesce(
    json_agg(
      jsonb_build_object(
        'id',         cr.id,
        'name',       cr.name,
        'code',       cr.code,
        'num_code',   cr.num_code, 
        'symbol',     cr.symbol,
        'created_at', cr.created_at,
        'updated_at', cr.updated_at
      )
    ) filter (where cr.id is not null), '[]') as currencies
  from country cn
  left join country_currency cc on cn.id = cc.country_id
  left join currency cr ON cc.currency_id = cr.id
 group by cn.id, cn.name
 order by $1::text
 limit  $3 offset $2
`

type CountryCurrencySelectParams struct {
	SqlOrder  string `json:"sql_order"`
	SqlOffset int32  `json:"sql_offset"`
	SqlLimit  int32  `json:"sql_limit"`
}

type CountryCurrencySelectRow struct {
	ID         string           `json:"id"`
	Name       string           `json:"name"`
	Iso2       string           `json:"iso2"`
	Iso3       string           `json:"iso3"`
	NumCode    int16            `json:"num_code"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	UpdatedAt  pgtype.Timestamp `json:"updated_at"`
	Currencies interface{}      `json:"currencies"`
}

// CountryCurrencySelect
//
//	select cn.id, cn.name, cn.iso2, cn.iso3, cn.num_code, cn.created_at, cn.updated_at,
//	  coalesce(
//	    json_agg(
//	      jsonb_build_object(
//	        'id',         cr.id,
//	        'name',       cr.name,
//	        'code',       cr.code,
//	        'num_code',   cr.num_code,
//	        'symbol',     cr.symbol,
//	        'created_at', cr.created_at,
//	        'updated_at', cr.updated_at
//	      )
//	    ) filter (where cr.id is not null), '[]') as currencies
//	  from country cn
//	  left join country_currency cc on cn.id = cc.country_id
//	  left join currency cr ON cc.currency_id = cr.id
//	 group by cn.id, cn.name
//	 order by $1::text
//	 limit  $3 offset $2
func (q *Queries) CountryCurrencySelect(ctx context.Context, arg *CountryCurrencySelectParams) ([]*CountryCurrencySelectRow, error) {
	rows, err := q.db.Query(ctx, countryCurrencySelect, arg.SqlOrder, arg.SqlOffset, arg.SqlLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*CountryCurrencySelectRow
	for rows.Next() {
		var i CountryCurrencySelectRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Iso2,
			&i.Iso3,
			&i.NumCode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Currencies,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countryDeleteByID = `-- name: CountryDeleteByID :one
delete from country c where c.id = $1 returning id
`

// CountryDeleteByID
//
//	delete from country c where c.id = $1 returning id
func (q *Queries) CountryDeleteByID(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRow(ctx, countryDeleteByID, id)
	err := row.Scan(&id)
	return id, err
}

const countryNew = `-- name: CountryNew :one
insert into country (
	name, iso2, iso3, num_code
) values (
	$1, $2, $3, $4
) returning id, name, iso2, iso3, num_code, created_at, updated_at
`

type CountryNewParams struct {
	Name    string `json:"name"`
	Iso2    string `json:"iso2"`
	Iso3    string `json:"iso3"`
	NumCode int16  `json:"num_code"`
}

// CountryNew
//
//	insert into country (
//		name, iso2, iso3, num_code
//	) values (
//		$1, $2, $3, $4
//	) returning id, name, iso2, iso3, num_code, created_at, updated_at
func (q *Queries) CountryNew(ctx context.Context, arg *CountryNewParams) (*Country, error) {
	row := q.db.QueryRow(ctx, countryNew,
		arg.Name,
		arg.Iso2,
		arg.Iso3,
		arg.NumCode,
	)
	var i Country
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Iso2,
		&i.Iso3,
		&i.NumCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const countrySelect = `-- name: CountrySelect :many
select id, name, iso2, iso3, num_code, created_at, updated_at
  from country c
 order by $1::text
 limit $3 offset $2
`

type CountrySelectParams struct {
	SqlOrder  string `json:"sql_order"`
	SqlOffset int32  `json:"sql_offset"`
	SqlLimit  int32  `json:"sql_limit"`
}

// CountrySelect
//
//	select id, name, iso2, iso3, num_code, created_at, updated_at
//	  from country c
//	 order by $1::text
//	 limit $3 offset $2
func (q *Queries) CountrySelect(ctx context.Context, arg *CountrySelectParams) ([]*Country, error) {
	rows, err := q.db.Query(ctx, countrySelect, arg.SqlOrder, arg.SqlOffset, arg.SqlLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Country
	for rows.Next() {
		var i Country
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Iso2,
			&i.Iso3,
			&i.NumCode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countrySelectByID = `-- name: CountrySelectByID :one
select id, name, iso2, iso3, num_code, created_at, updated_at from country c where c.id = $1
`

// CountrySelectByID
//
//	select id, name, iso2, iso3, num_code, created_at, updated_at from country c where c.id = $1
func (q *Queries) CountrySelectByID(ctx context.Context, id string) (*Country, error) {
	row := q.db.QueryRow(ctx, countrySelectByID, id)
	var i Country
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Iso2,
		&i.Iso3,
		&i.NumCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const countryUpdateByID = `-- name: CountryUpdateByID :one
update country
   set name = $1, iso2 = $2, iso3 = $3, num_code = $4
 where id = $5
       returning id, name, iso2, iso3, num_code, created_at, updated_at
`

type CountryUpdateByIDParams struct {
	Name    string `json:"name"`
	Iso2    string `json:"iso2"`
	Iso3    string `json:"iso3"`
	NumCode int16  `json:"num_code"`
	ID      string `json:"id"`
}

// CountryUpdateByID
//
//	update country
//	   set name = $1, iso2 = $2, iso3 = $3, num_code = $4
//	 where id = $5
//	       returning id, name, iso2, iso3, num_code, created_at, updated_at
func (q *Queries) CountryUpdateByID(ctx context.Context, arg *CountryUpdateByIDParams) (*Country, error) {
	row := q.db.QueryRow(ctx, countryUpdateByID,
		arg.Name,
		arg.Iso2,
		arg.Iso3,
		arg.NumCode,
		arg.ID,
	)
	var i Country
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Iso2,
		&i.Iso3,
		&i.NumCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
